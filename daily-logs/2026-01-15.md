# 2026-01-15 작업 일지

## 오늘 완료한 작업

### 1. 이벤트 기반 아키텍처 구축 (1~3단계)

기존 코드가 직접 호출 방식이라 확장성이 떨어졌음. 이벤트 기반으로 리팩토링.

#### 생성된 파일
| 파일 | 역할 |
|------|------|
| `Scripts/Core/CatEventSystem.cs` | 이벤트 중앙 관리 (싱글톤) |
| `Scripts/Core/CatBehaviorController.cs` | 행동/반응 처리 컨트롤러 |

#### CatEventSystem 주요 기능
```csharp
// 상호작용 타입
public enum InteractionType
{
    Feed,       // 밥 주기
    Pet,        // 쓰다듬기
    Play,       // 장난감 놀이
    Talk,       // 대화하기
    GiveSnack,  // 간식 주기
    Brush,      // 빗질
    Bath        // 목욕
}

// 이벤트 발생
CatEventSystem.TriggerFeed(position);
CatEventSystem.TriggerPet(intensity, position);
CatEventSystem.TriggerPlay(intensity, position);
```

#### CatBehaviorController 주요 기능
- 이벤트 수신 → 애니메이션/이펙트/상태 변화 처리
- 친밀도 증가/감소 중앙 관리
- AI 반응 트리거 (확률적)

### 2. 기존 코드 마이그레이션

#### FoodBowlUI.cs
```csharp
// 이전: 직접 CatInteraction 호출
var catState = _catInteraction.GetCatState();
catState.Hunger = 0f;
_catInteraction.ShowHeart();

// 이후: 이벤트 시스템 사용
CatEventSystem.TriggerFeed((Vector3)BowlPosition);
```

#### CatInteraction.cs
```csharp
// 이전: 직접 친밀도 증가
_catState.IncreaseAffection(_affectionIncreaseAmount);
PlayReactionEffect();

// 이후: 이벤트 시스템 사용
CatEventSystem.TriggerPet(1f, transform.position);
```

### 3. 고양이 자율 행동 시스템 구현

#### CatMovement.cs 전면 개편
```csharp
public enum CatBehavior
{
    Idle,       // 가만히 있기 (2~8초)
    Walking,    // 걷기 (1~4초)
    Running,    // 뛰기 (20% 확률)
    Grooming,   // 그루밍 (15% 확률)
    GoingToEat, // 밥 먹으러 가는 중
    Eating      // 밥 먹는 중
}
```

**주요 변경사항**:
- 클릭 이동 제거 → 자율 행동으로 변경
- 랜덤하게 걷기/뛰기/그루밍/가만히 있기
- 배고프면 자동으로 밥그릇으로 이동
- 방향에 따라 스프라이트 좌우 반전

#### InputHandler.cs
- 화면 클릭 시 이동 로직 제거
- 고양이 클릭(쓰다듬기)만 유지

### 4. 배고픔 시스템 개선

#### CatHunger.cs 개선
```csharp
// 배고픔 단계별 메시지
배고픔 70~89 → "배고프당...", "밥 먹고 싶어"
배고픔 90+   → "너무 배고파ㅠㅠ", "밥 달라고!!!"

// 조른 횟수에 따라 다른 메시지
1번째: "배고프당..."
2번째: "밥... 밥 줘!"
3번째+: "밥!!!", "왜 안 줘ㅠㅠ"
```

**동작 흐름**:
1. 배고픔 70 이상 + 밥 있음 → CatMovement가 밥그릇으로 이동 → 먹기
2. 배고픔 70 이상 + 밥 없음 → 채팅으로 밥 달라고 조르기

### 5. 이동 범위 설정

#### 창문 기준 바닥 Y 좌표
```csharp
[SerializeField] private float _groundY = -2.5f;  // Inspector에서 직접 설정
[SerializeField] private bool _autoCalculateGround = false;  // 자동 계산 옵션
```

**문제 발생**: 자동 계산 시 Canvas RenderMode에 따라 좌표 변환 오류
**해결**: Inspector에서 직접 `_groundY` 값 설정하는 것을 권장

---

## 새로 배운 개념

### 1. 이벤트 기반 아키텍처 (Event-Driven Architecture)

```
[직접 호출 방식 - 강결합]
FoodBowlUI → CatInteraction → CatState
       ↘ 직접 참조 필요 ↗

[이벤트 기반 방식 - 약결합]
FoodBowlUI → CatEventSystem ← CatBehaviorController
             (이벤트 버스)      (구독자)
```

**장점**:
- 컴포넌트 간 독립성 (느슨한 결합)
- 새 기능 추가가 쉬움
- 테스트/디버깅 용이

**단점**:
- 흐름 추적이 어려울 수 있음
- 초기 설계 복잡

### 2. C# EventHandler 패턴

```csharp
// 이벤트 데이터 클래스
public class InteractionEventArgs : EventArgs
{
    public InteractionType Type { get; }
    public float Intensity { get; }
    public Vector3 Position { get; }
    public DateTime Timestamp { get; }
}

// 이벤트 선언
public static event EventHandler<InteractionEventArgs> OnInteraction;

// 이벤트 발생
OnInteraction?.Invoke(Instance, args);

// 이벤트 구독
CatEventSystem.OnInteraction += HandleInteraction;

// 이벤트 구독 해제 (중요!)
CatEventSystem.OnInteraction -= HandleInteraction;
```

### 3. Action vs EventHandler

```csharp
// Action: 단순한 델리게이트
public static event Action<BehaviorState> OnBehaviorStateChanged;
OnBehaviorStateChanged?.Invoke(newState);

// EventHandler: 표준 이벤트 패턴 (sender 포함)
public static event EventHandler<InteractionEventArgs> OnInteraction;
OnInteraction?.Invoke(sender, args);
```

**사용 기준**:
- Action: 단순 알림, sender 불필요
- EventHandler: 상세 데이터 전달, 표준 패턴 준수

### 4. 고양이 AI 행동 패턴

```csharp
private void DecideNextBehavior()
{
    // 우선순위 1: 배고프면 밥 먹으러 가기
    if (ShouldGoEat())
    {
        GoToFoodBowl();
        return;
    }

    // 랜덤 행동 선택 (확률 기반)
    float random = Random.value;

    if (random < _groomChance)           // 15%
        StartGrooming();
    else if (random < _groomChance + _runChance)  // 35%
        StartRunning();
    else if (random < 0.6f)              // 60%
        StartWalking();
    else
        StartRandomIdleBehavior();       // 40%
}
```

### 5. 스프라이트 방향 전환

```csharp
private void UpdateFacingDirection()
{
    float direction = _targetPosition.x - transform.position.x;

    // 오른쪽으로 가면 flipX = false
    // 왼쪽으로 가면 flipX = true
    if (Mathf.Abs(direction) > 0.1f)
    {
        _spriteRenderer.flipX = direction < 0;
    }
}
```

---

## 아키텍처 변경 요약

### 이전 구조 (직접 호출)
```
FoodBowlUI ──────→ CatInteraction ──→ CatState
                        ↑
InputHandler ───────────┘
CatHunger ──────────────┘
```

### 현재 구조 (이벤트 기반)
```
FoodBowlUI ────┐
InputHandler ──┼──→ CatEventSystem ──→ CatBehaviorController ──→ CatState
CatHunger ─────┘         ↑                       ↓
CatMovement ─────────────┼───────────────────────┘
```

---

## 오늘 발생한 문제들

### 1. Vector2 → Vector3 변환 에러
```csharp
// 문제: BowlPosition이 Vector2인데 Vector3 기대
CatEventSystem.TriggerFeed(BowlPosition);  // 에러!

// 해결: 명시적 캐스팅
CatEventSystem.TriggerFeed((Vector3)BowlPosition);
```

### 2. 창문 좌표 계산 오류 (망고가 하늘로!)
```csharp
// 문제: GetWorldCorners가 Canvas RenderMode에 따라 다른 좌표 반환
// Screen Space Overlay: Screen 좌표
// World Space: World 좌표

// 해결: Inspector에서 직접 _groundY 값 설정
[SerializeField] private float _groundY = -2.5f;
[SerializeField] private bool _autoCalculateGround = false;
```

### 3. VSCode C# 프로젝트 로드 실패
```
[error] Failed to load project 'Assembly-CSharp.csproj'
```
**원인**: Unity 프로젝트는 일반 .NET 프로젝트가 아니라서 C# Dev Kit이 인식 못함
**해결**: 무시해도 됨, Unity Console에서 에러 확인하면 됨

---

## Unity에서 설정해야 할 것

### 1. CatEventSystem & CatBehaviorController 추가
1. Hierarchy에서 빈 GameObject 생성 → 이름: `GameManager`
2. `CatEventSystem` 컴포넌트 추가
3. `CatBehaviorController` 컴포넌트 추가
4. Inspector에서 `Heart Effect Prefab` 연결

### 2. CatMovement 설정
1. 고양이 오브젝트의 `CatMovement` 컴포넌트
2. `Ground Y`: 바닥 높이 (예: -2.5)
3. `Min X`, `Max X`: 좌우 이동 범위
4. `Auto Calculate Ground`: false (수동 설정 권장)

---

## 다음 작업 예정

### AI 연동 준비 (4단계)
- [ ] CatContextManager 생성 (상호작용 데이터 수집)
- [ ] AI 프롬프트에 컨텍스트 전달
- [ ] 행동 기반 AI 반응 트리거

### Phase 1: 초기 설정 UI
- [ ] 게임 시작 시 이름 입력
- [ ] 고양이/사용자 생일 설정

---

## 오늘 배운 교훈

1. **이벤트 시스템은 미리 설계하자**: 나중에 리팩토링하면 시간 많이 듦
2. **좌표 변환 주의**: Canvas RenderMode에 따라 GetWorldCorners 결과가 다름
3. **Inspector 설정 활용**: 복잡한 계산보다 직접 설정이 안정적일 때도 있음
4. **자율 행동 AI는 확률 기반**: 랜덤 값으로 자연스러운 행동 패턴 생성

---

## 참고 자료
- Unity Events: https://docs.unity3d.com/Manual/UnityEvents.html
- C# EventHandler: https://learn.microsoft.com/ko-kr/dotnet/standard/events/
- Unity RectTransform: https://docs.unity3d.com/Manual/class-RectTransform.html
